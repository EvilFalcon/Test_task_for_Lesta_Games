# Test_task_for_Lesta_Games
 
## Задание № 1 . С кодом можно ознакомиться [здесь](https://github.com/EvilFalcon/Test_task_for_Lesta_Games/blob/main/Test_task_for_Lesta_Games/tasks/exercise_1.py).

#### Плюсы предложенной реализации:
Простая и понятная логика: использует стандартный оператор остатка от деления.
Эффективная: работает быстро для всех типов целых чисел.

#### Минусы:
Не использует специфику задачи: для определения четности не требуется вычисление остатка.

### Моя реализация предполагает побитовую проверку

#### Плюсы:
Более эффективна: использует битовую операцию AND, которая быстрее, чем операция остатка от деления, особенно для больших чисел.
Использует специфику задачи: четное число всегда имеет нулевой младший бит.

#### Минусы:
Менее очевидна: требует понимания битовых операций.

#### Сравнение:
Моя реализация будет быстрее, особенно для больших чисел.

## Задание №2 (Циклический буфер FIFO). С кодом можно ознакомиться [здесь](https://github.com/EvilFalcon/Test_task_for_Lesta_Games/blob/main/Test_task_for_Lesta_Games/tasks/exercise_2.py).

### Реализация 1: С использованием списка.

#### Плюсы:
Простая реализация: использует стандартный список Python.
Легко понять: код интуитивно понятен.
Минусы:
Неэффективна: при переполнении буфера приходится перемещать все элементы, что может быть затратно по времени.

### Реализация 2: С использованием двусвязного списка.

#### Плюсы:
Эффективна: операции вставки и удаления элементов происходят за O(1) время.
Использует структуры данных: использует двусвязный список для реализации циклического буфера.

#### Минусы:
Сложнее в реализации: требует понимания работы двусвязных списков.
Дополнительная память: требуется больше памяти для хранения узлов списка.

#### Сравнение:
Реализация 2 (с использованием двусвязного списка) более эффективна, особенно для больших объемов данных. Однако, она более сложна в реализации. Выбор реализации зависит от конкретных потребностей приложения.

## Задание №3 (Быстрая сортировка)  С кодом можно ознакомиться [здесь](https://github.com/EvilFalcon/Test_task_for_Lesta_Games/blob/main/Test_task_for_Lesta_Games/tasks/exercise_3.py)

### "Почему эта функция соответствует критериям:

Скорость: Алгоритм Quicksort имеет среднюю сложность O(n log n), что делает его одним из самых быстрых алгоритмов сортировки.
Адаптивность: Алгоритм эффективен для массивов любого размера и с любым начальным порядком.
Простота: Реализация алгоритма относительно проста, что делает его удобным для использования.

#### Важно отметить:
Алгоритм Quicksort имеет худшую сложность O(n^2) в случае, если пивот выбирается не оптимально.
Для небольших массивов (n < 10) более эффективным может быть алгоритм сортировки вставками (Insertion Sort) или сортировка выбором (Selection Sort).
В Python есть встроенная функция sort, которая использует оптимизированный алгоритм сортировки, поэтому в большинстве случаев нет необходимости реализовывать свой алгоритм сортировки.
Дополнительные сведения:"
